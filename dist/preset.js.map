{"version":3,"sources":["../src/csfParser.ts","../src/preset.ts"],"names":["YAML","getStorage","toId","storage","csfParser","resourcePath","src","makeTitle","namespaces","patternDefinition","patternIds","defaultPatternId","defaultPattern","defaultPatternLabel","defaultPatternNamespace","namespacePath","key","title","stories","meta","patternId","definition","variants","variantName","variantLabel","formattedVariantLabel","story","fs","path","readFileSync","babylon","traverse","env","config","options","relativeNamespaces","webpackAliases","appPath","namespace","webpack","rules","plugins","__require","storyIndexers","indexers","absoluteNamespaces","formattedNamespace","fileName","opts","ast","absYamlPath","pathItem","yamlPath","ymlSrc"],"mappings":"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","sourcesContent":["import type { IndexedCSFFile, IndexedStory } from \"@storybook/types\";\n\nimport type { StaticMeta } from \"@storybook/csf-tools\";\nimport YAML from \"yaml\";\nimport { getStorage, Namespaces } from \"@cmbr/sb-patterns\";\nimport { toId } from \"@storybook/csf\";\n\nconst storage = getStorage();\n\nexport function csfParser(\n  resourcePath: string,\n  src: string,\n  makeTitle: (input: string) => string,\n  namespaces: Namespaces = {}\n): IndexedCSFFile {\n  const patternDefinition = YAML.parse(src);\n\n  const patternIds = Object.keys(patternDefinition);\n  const defaultPatternId = patternIds[0];\n  if (!defaultPatternId) {\n    throw new Error(`No patterns found in ${resourcePath}`);\n  }\n  const defaultPattern = patternDefinition[defaultPatternId];\n  const defaultPatternLabel = defaultPattern.label ?? defaultPatternId;\n  let defaultPatternNamespace = defaultPattern.namespace ?? \"\";\n\n  let namespacePath = defaultPatternNamespace;\n  if (defaultPatternNamespace === \"\") {\n    Object.keys(namespaces).forEach((key) => {\n      if (\n        resourcePath.startsWith(namespaces[key]) &&\n        namespaces[key].length > namespacePath.length\n      ) {\n        defaultPatternNamespace = key;\n        namespacePath = namespaces[key];\n      }\n    });\n  }\n\n  const title = defaultPatternNamespace + \"/\" + defaultPatternLabel;\n  const stories: IndexedStory[] = [];\n  const meta: StaticMeta = {\n    title: makeTitle(title),\n    tags: [\"autodocs\"],\n  };\n\n  patternIds.forEach((patternId) => {\n    const definition = patternDefinition[patternId];\n    // Add definition to use in the storiesLoader.\n    // This def might not be complete since it's coming from the YAML file,\n    // but should be good enough to grab the code example, which is what we're\n    // concerned with here.\n    storage.addDefinition(patternId, definition);\n\n    const variants = definition.variants ?? { __default: { label: \"Default\" } };\n    Object.keys(variants).forEach((variantName) => {\n      const variantLabel = variants[variantName].label;\n      const formattedVariantLabel = variantLabel.replace(/[^a-zA-Z0-9]/g, \"_\");\n\n      const story: IndexedStory = {\n        id: toId(title, patternId + \"-\" + formattedVariantLabel),\n        name: variantLabel,\n      };\n\n      stories.push(story);\n    });\n  });\n\n  return {\n    meta,\n    stories,\n  };\n}\n","import { Configuration } from \"webpack\";\nimport type { IndexerOptions, StoryIndexer } from \"@storybook/types\";\n\nimport { AddonPatternOptions } from \"@cmbr/sb-patterns\";\nimport { csfParser } from \"./csfParser\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { readFileSync } from \"fs\";\n\nconst babylon = require(\"babylon\");\nconst traverse = require(\"babel-traverse\").default;\n\ninterface EnvConfiguration extends Configuration {\n  NAMESPACES: string;\n}\n\nexport function env(\n  config: Configuration,\n  options: AddonPatternOptions\n): EnvConfiguration {\n  const relativeNamespaces: Record<string, string> = {};\n  const webpackAliases = options.webpackAliases || {};\n  const appPath = options.appPath || \"\";\n\n  Object.keys(webpackAliases).forEach((namespace) => {\n    relativeNamespaces[namespace] = webpackAliases[namespace].replace(\n      appPath,\n      \".\"\n    );\n  });\n\n  return {\n    ...config,\n    NAMESPACES: JSON.stringify(relativeNamespaces),\n  };\n}\n\nexport function webpack(\n  config: Configuration,\n  options: AddonPatternOptions\n): Configuration {\n  const rules = config.module?.rules || [];\n  const plugins = config.plugins || [];\n\n  return {\n    ...config,\n    module: {\n      ...config.module,\n      rules: [\n        ...rules,\n        {\n          test: /\\.yml/,\n          use: [\"js-yaml-loader\"],\n        },\n        {\n          test: /\\.wingsuit\\.(ts|tsx)$/,\n          enforce: \"post\",\n          use: [\n            {\n              loader: require.resolve(\"./storiesLoader\"),\n            },\n          ],\n        },\n      ],\n    },\n  };\n}\n\nexport const storyIndexers = async (\n  indexers: StoryIndexer[] | null,\n  options: AddonPatternOptions\n) => {\n  const webpackAliases = options.webpackAliases || {};\n  const absoluteNamespaces: Record<string, string> = {};\n\n  Object.keys(webpackAliases).forEach((namespace) => {\n    const formattedNamespace = namespace.replace(\"@\", \"\");\n    absoluteNamespaces[formattedNamespace] = webpackAliases[namespace];\n  });\n\n  const csfIndexer = async (fileName: string, opts: IndexerOptions) => {\n    const src = readFileSync(fileName, \"utf-8\").toString();\n\n    const ast = babylon.parse(src, {\n      sourceType: \"module\",\n    });\n\n    let absYamlPath = \"\";\n\n    traverse(ast, {\n      VariableDeclaration(pathItem: any) {\n        if (pathItem.node.declarations[0].id.name === \"patternDefinition\") {\n          const yamlPath =\n            pathItem.node.declarations[0].init.arguments[0].value;\n          if (yamlPath.startsWith(\".\") || yamlPath.startsWith(\"/\")) {\n            absYamlPath = path.join(path.dirname(fileName), yamlPath);\n          } else {\n            absYamlPath = require.resolve(yamlPath);\n          }\n        }\n      },\n    });\n\n    const ymlSrc = fs.readFileSync(absYamlPath, \"utf8\");\n    const code = csfParser(\n      fileName,\n      ymlSrc,\n      opts.makeTitle,\n      absoluteNamespaces\n    );\n    return code;\n  };\n\n  return [\n    {\n      test: /\\.wingsuit\\.(ts|tsx)$/,\n      indexer: csfIndexer,\n    },\n    ...(indexers || []),\n  ];\n};\n"]}