{"version":3,"sources":["../src/preset.ts","../src/csfParser.ts"],"names":["DefinePlugin","YAML","storage","toId","csfParser","resourcePath","src","makeTitle","namespaces","patternDefinition","patternIds","defaultPatternId","defaultPattern","defaultPatternLabel","defaultPatternNamespace","namespacePath","key","title","stories","meta","patternId","definition","variants","variantName","variantLabel","formattedVariantLabel","story","fs","path","readFileSync","babylon","traverse","config","entry","__require","env","options","relativeNamespaces","webpackAliases","appPath","namespace","webpack","rules","plugins","storyIndexers","indexers","absoluteNamespaces","formattedNamespace","fileName","opts","ast","absYamlPath","pathItem","yamlPath","ymlSrc"],"mappings":"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","sourcesContent":["import { Configuration, DefinePlugin } from \"webpack\";\nimport type { IndexerOptions, StoryIndexer } from \"@storybook/types\";\n\nimport { AddonPatternOptions } from \"sb-patterns\";\nimport { csfParser } from \"./csfParser\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { readFileSync } from \"fs\";\n\nconst babylon = require(\"babylon\");\nconst traverse = require(\"babel-traverse\").default;\n\ninterface EnvConfiguration extends Configuration {\n  NAMESPACES: string;\n}\n\nexport function config(entry: string[] = []) {\n  return [...entry, require.resolve(\"./configuration\")];\n}\n\nexport function env(\n  config: Configuration,\n  options: AddonPatternOptions\n): EnvConfiguration {\n  const relativeNamespaces: Record<string, string> = {};\n  const webpackAliases = options.webpackAliases || {};\n  const appPath = options.appPath || \"\";\n\n  Object.keys(webpackAliases).forEach((namespace) => {\n    relativeNamespaces[namespace] = webpackAliases[namespace].replace(\n      appPath,\n      \".\"\n    );\n  });\n\n  return {\n    ...config,\n    NAMESPACES: JSON.stringify(relativeNamespaces),\n  };\n}\n\nexport function webpack(\n  config: Configuration,\n  options: AddonPatternOptions\n): Configuration {\n  const rules = config.module?.rules || [];\n  const plugins = config.plugins || [];\n\n  return {\n    ...config,\n    plugins: [\n      ...plugins,\n      new DefinePlugin({\n        STORIES_CONTEXT: JSON.stringify(options.storiesContexts),\n      }),\n    ],\n    module: {\n      ...config.module,\n      rules: [\n        ...rules,\n        {\n          test: /\\.yml/,\n          use: [\"js-yaml-loader\"],\n        },\n        {\n          test: /\\.wingsuit\\.(ts|tsx)$/,\n          enforce: \"post\",\n          use: [\n            {\n              loader: require.resolve(\"./storiesLoader\"),\n            },\n          ],\n        },\n      ],\n    },\n  };\n}\n\nexport const storyIndexers = async (\n  indexers: StoryIndexer[] | null,\n  options: AddonPatternOptions\n) => {\n  const webpackAliases = options.webpackAliases || {};\n  const absoluteNamespaces: Record<string, string> = {};\n\n  Object.keys(webpackAliases).forEach((namespace) => {\n    const formattedNamespace = namespace.replace(\"@\", \"\");\n    absoluteNamespaces[formattedNamespace] = webpackAliases[namespace];\n  });\n\n  const csfIndexer = async (fileName: string, opts: IndexerOptions) => {\n    const src = readFileSync(fileName, \"utf-8\").toString();\n\n    const ast = babylon.parse(src, {\n      sourceType: \"module\",\n    });\n\n    let absYamlPath = \"\";\n\n    traverse(ast, {\n      VariableDeclaration(pathItem: any) {\n        if (pathItem.node.declarations[0].id.name === \"patternDefinition\") {\n          const yamlPath =\n            pathItem.node.declarations[0].init.arguments[0].value;\n          if (yamlPath.startsWith(\".\") || yamlPath.startsWith(\"/\")) {\n            absYamlPath = path.join(path.dirname(fileName), yamlPath);\n          } else {\n            absYamlPath = require.resolve(yamlPath);\n          }\n        }\n      },\n    });\n\n    const ymlSrc = fs.readFileSync(absYamlPath, \"utf8\");\n    const code = csfParser(\n      fileName,\n      ymlSrc,\n      opts.makeTitle,\n      absoluteNamespaces\n    );\n    return code;\n  };\n\n  return [\n    {\n      test: /\\.wingsuit\\.(ts|tsx)$/,\n      indexer: csfIndexer,\n    },\n    ...(indexers || []),\n  ];\n};\n","import type { IndexedCSFFile, IndexedStory } from '@storybook/types';\n\nimport type { StaticMeta } from '@storybook/csf-tools';\nimport YAML from 'yaml';\nimport { storage, Namespaces } from 'sb-patterns';\nimport { toId } from '@storybook/csf';\n\nexport function csfParser(\n  resourcePath: string,\n  src: string,\n  makeTitle: (input: string) => string,\n  namespaces: Namespaces = {}\n): IndexedCSFFile {\n  const patternDefinition = YAML.parse(src);\n\n  const patternIds = Object.keys(patternDefinition);\n  const defaultPatternId = patternIds[0];\n  if (!defaultPatternId) {\n    throw new Error(`No patterns found in ${resourcePath}`);\n  }\n  const defaultPattern = patternDefinition[defaultPatternId];\n  const defaultPatternLabel = defaultPattern.label ?? defaultPatternId;\n  let defaultPatternNamespace = defaultPattern.namespace ?? '';\n\n  let namespacePath = defaultPatternNamespace;\n  if (defaultPatternNamespace === '') {\n    Object.keys(namespaces).forEach((key) => {\n      if (\n        resourcePath.startsWith(namespaces[key]) &&\n        namespaces[key].length > namespacePath.length\n      ) {\n        defaultPatternNamespace = key;\n        namespacePath = namespaces[key];\n      }\n    });\n  }\n\n  const title = defaultPatternNamespace + '/' + defaultPatternLabel;\n  const stories: IndexedStory[] = [];\n  const meta: StaticMeta = {\n    title: makeTitle(title),\n    tags: ['autodocs'],\n  };\n\n  patternIds.forEach((patternId) => {\n    const definition = patternDefinition[patternId];\n    // Add definition to use in the storiesLoader.\n    // This def might not be complete since it's coming from the YAML file,\n    // but should be good enough to grab the code example, which is what we're\n    // concerned with here.\n    storage.addDefinition(patternId, definition);\n\n    const variants = definition.variants ?? { __default: { label: 'Default' } };\n    Object.keys(variants).forEach((variantName) => {\n      const variantLabel = variants[variantName].label;\n      const formattedVariantLabel = variantLabel.replace(/[^a-zA-Z0-9]/g, '_');\n\n      const story: IndexedStory = {\n        id: toId(title, patternId + '-' + formattedVariantLabel),\n        name: variantLabel,\n      };\n\n      stories.push(story);\n    });\n  });\n\n  return {\n    meta,\n    stories,\n  };\n}\n"]}